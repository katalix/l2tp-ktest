#!/bin/bash
#
# SPDX-License-Identifier: GPL-2.0-or-later
#
# Test suite for Linux Kernel L2TP code
#
# Depends on iproute2 with l2tp support
#

readonly KMEMLEAK=/sys/kernel/debug/kmemleak

DO_KMODREFLEAK_CHECK=0
DO_KMEMLEAK_CHECK=0
TESTCASES=
CHECK_COUNT=0
CHECK_FAIL=0
EXIT_ON_FIRST_ERROR=0
VERBOSE=0

log() { echo "[$(date)] $@"; }
err() { log "ERROR: $@" 1>&2; false; }
die() { log "FATAL: $@" 1>&2; exit 1; }
dbg() { test $VERBOSE -ne 0 && log "$@"; }

KMODREFLEAK_BEFORE=""
kmodrefleak_setup()
{
    if test 1 -eq $DO_KMODREFLEAK_CHECK -o "$1" = "force"
    then
        KMODREFLEAK_BEFORE="$(lsmod | grep l2tp)"
    fi
}

kmodrefleak_check()
{
    local ret=0
    if test 1 -eq $DO_KMODREFLEAK_CHECK -o "$1" = "force"
    then
        # wait for netdev shutdown grace period before testing module refcounts
        sleep 2
        diff -u <( echo "$KMODREFLEAK_BEFORE" ) <( lsmod | grep l2tp ) || ret=1
    fi
    return $ret
}

runtest()
{
    local ret=0

    kmodrefleak_setup
    kmemleak_clear
    type pre_$1 &> /dev/null && pre_$1

    $1
    ret=$?

    type post_$1 &> /dev/null && post_$1
    kmemleak_check || {
        err "kernel memory leak detected for testcase $1"
        cat $KMEMLEAK
    }

    test $ret -eq 0 && kmodrefleak_check || ret=1
    return $ret
}

report_and_exit() {
    local ntests=$1
    local check_count=$2
    local nfails=$3
    local exit_code=$4
    local reason=""
    test $exit_code -eq 0 || reason="(aborted)"
    log "Summary: $ntests testcases run ($check_count checks), of which $nfails failed $reason"
    exit $exit_code
}

check()
{
    dbg "$@"
    CHECK_COUNT=$((CHECK_COUNT+1))
    if ! $@
    then
        err "$@ failed on line ${BASH_LINENO[0]} in ${FUNCNAME[1]}"
        CHECK_FAIL=$((CHECK_FAIL+1))
        test $EXIT_ON_FIRST_ERROR -eq 0 || report_and_exit $ntests $CHECK_COUNT 1 1
    fi
}

# ip l2tp wrappers
count_tunnels() { ip l2tp show tunnel | grep -c ^Tunnel; }
count_sessions() { ip l2tp show session | grep -e " in tunnel $1" | grep -c ^Session; }
get_tunnel_ids() { ip l2tp show tunnel | awk '/^Tun/ { gsub(/,/, ""); print $2; }'; }
get_session_ids() { ip l2tp show session | grep -e " in tunnel $1" | awk '/^Session/ { gsub(/,/, ""); print $2; }'; }
is_tunnel() { local i; for i in $(get_tunnel_ids); do if test $i -eq $1; then return 0; fi; done; return 1; }
delay_no_tunnel() {
    local i=0
    # some kernels seem to lag on tunnel destroy, so let's try to account for that
    while test $(count_tunnels) -ne 0 && test $i -lt 20; do sleep 0.2s; i=$((i+1)); done
}
close_tunnel() {
    local i=0
    ip l2tp del tunnel tunnel_id $1 || return $?
    local s; for s in $(get_session_ids $1); do ip l2tp del session tunnel_id $1 session_id $s; done
    # some kernels seem to lag on tunnel destroy, so let's try to account for that
    while is_tunnel $1 && test $i -lt 20; do sleep 0.2s; i=$((i+1)); done
}

# kmemleak wrappers
kmemleak_clear()
{
    if test 1 -eq $DO_KMEMLEAK_CHECK && test -f $KMEMLEAK
    then
        /bin/echo clear > $KMEMLEAK
    fi
}

kmemleak_check()
{
    if test 1 -eq $DO_KMEMLEAK_CHECK && test -f $KMEMLEAK
    then
        /bin/echo scan > $KMEMLEAK
        test 0 -eq $(wc -l $KMEMLEAK | cut -d" " -f1)
    else
        return 0
    fi
}

# version-specifics
current_kernel_version() { awk '/^Linux version/ { split($3, a, /\./); gsub(/[^0-9].*$/, "",a[3]); print a[1], a[2], a[3] }' /proc/version; }
kernel_version() { echo $(( ($1 << 16) + ($2 << 8) + $3 )); }

have_ipv6() { test $(kernel_version $(current_kernel_version)) -ge $(kernel_version 3 5 0); }
have_l2tpip_ipv6() { test $(kernel_version $(current_kernel_version)) -ge $(kernel_version 3 8 0); }
have_ipv6_peer() { test $(kernel_version $(current_kernel_version)) -ge $(kernel_version 3 11 0); }
have_ip_netns() { test $(kernel_version $(current_kernel_version)) -ge $(kernel_version 3 8 0); }
have_udp_encap_destroy() { test $(kernel_version $(current_kernel_version)) -ge $(kernel_version 3 9 0); }
have_l2tp_ac_pppoe() { grep -q l2tp_ac_pppoe /lib/modules/$(uname -r)/modules.dep; }

# Tunnel / session lifetimes

# $1 -- version
# $2 -- create api
# $3 -- delete api
# $4 -- encap
# $5 -- family
# $6 -- optional pw type (no pw if not defined)
managed_tunl_check()
{
    local pw=""
    test -n "$6" && pw="-p $6"

    # Note that older kernels w/o the udp encap_destroy hook are not
    # able to successfully close l2tp tunnel contexts in the kernel
    # on close of the userspace socket.

    # Make sure we don't have any tunnels to start off with
    check test $(count_tunnels) -eq 0

    # App exit without closing the tunnel should result in tunnel delete
    check $(dirname $0)/kcreate -v $1 -m -n -c $2 -d $3 -e $4 -f $5 $pw
    delay_no_tunnel
    test $HAVE_UDP_ENCAP_DESTROY -eq 1 && check test $(count_tunnels) -eq 0

    # Force close any extant tunnels: they should close when asked with
    # iproute or it's a failure.
    for i in $(get_tunnel_ids); do check close_tunnel $i; done
    check test $(count_tunnels) -eq 0
    test $(count_tunnels) -eq 0 || report_and_exit $ntests $CHECK_COUNT 1 1

    # App exit after closing the tunnel should result in tunnel delete,
    # *unless* we're using socket close for a kernel w/o the
    # udp encap_destroy hook
    check $(dirname $0)/kcreate -v $1 -m -c $2 -d $3 -e $4 -f $5 $pw
    delay_no_tunnel
    if test $HAVE_UDP_ENCAP_DESTROY -eq 1 || test $3 = "netlink"
    then
        check test $(count_tunnels) -eq 0
    fi

    # Close any tunnels still around
    for i in $(get_tunnel_ids); do check close_tunnel $i; done
    test $(count_tunnels) -eq 0 || report_and_exit $ntests $CHECK_COUNT 1 1
}

# $1 -- version
# $2 -- create api
# $3 -- delete api
# $4 -- encap
# $5 -- family
# $6 -- optional pw type (no pw if not defined)
unmanaged_tunl_check()
{
    local pw=""
    test -n "$6" && pw="-p $6"

    # Make sure we don't have any tunnels to start off with
    check test $(count_tunnels) -eq 0

    # App exit without closing the tunnel should not result in tunnel delete
    check $(dirname $0)/kcreate -v $1 -n -c $2 -d $3 -e $4 -f $5 $pw
    check test $(count_tunnels) -eq 1

    # Close the newly created tunnel(s)
    for i in $(get_tunnel_ids); do check close_tunnel $i; done
    check test $(count_tunnels) -eq 0

    # App exit after closing the tunnel should result in tunnel delete
    check $(dirname $0)/kcreate -v $1 -c $2 -d $3 -e $4 -f $5 $pw
    delay_no_tunnel
    check test $(count_tunnels) -eq 0

    # Close any tunnels still around
    for i in $(get_tunnel_ids); do check close_tunnel $i; done
    test $(count_tunnels) -eq 0 || report_and_exit $ntests $CHECK_COUNT 1 1
}

# $1 -- encap
# $2 -- family
# $3 -- pseudowire
v3_tunl_check()
{
    # We should be able to destroy a managed tunnel using both the socket
    # and the netlink APIs
    managed_tunl_check 3 netlink netlink "$1" "$2" "$3"
    managed_tunl_check 3 netlink socket "$1" "$2" "$3"

    # In the special case of PPP pseudowires, there is a socket API for
    # tunnel and session creation, so check all permutations of that
    if test "$3" = "ppp" && test "$1" = "udp"
    then
        managed_tunl_check 3 socket netlink "$1" "$2" "$3"
        managed_tunl_check 3 socket socket "$1" "$2" "$3"
    fi

    # Unmanaged tunnels are only accessible via the netlink API
    unmanaged_tunl_check 3 netlink netlink "$1" "$2" "$3"
}

# L2TPv2 is UDP encap, PPP pw only
# $1 -- family
# $2 -- pseudowire
v2_tunl_check()
{
    # We should be able to create/destroy a managed tunnel using both the
    # socket and the netlink APIs
    managed_tunl_check 2 netlink netlink udp "$1" "$2"
    managed_tunl_check 2 netlink socket udp "$1" "$2"
    managed_tunl_check 2 socket netlink udp "$1" "$2"
    managed_tunl_check 2 socket socket udp "$1" "$2"

    # Unmanaged v2 tunnels aren't allowed
}

# $1 -- L2TP version
# $2 -- family
# $3 -- encap
# $4 -- pseudowire
# $5 -- cookie_len
session_data_check()
{
    check $(dirname $0)/netns_datapath datapath $@
}

# $1 -- family
# $2 -- encap
# $3 -- pseudowire
# $4 -- cookie_len
# $5 -- bad_cookie_len
cookie_mismatch_check()
{
    $(dirname $0)/netns_datapath cookie_mismatch $@
}

# $1 -- L2TP version
# $2 -- family
# $3 -- encap
# $4 -- pseudowire
data_shutdown_check()
{
    check $(dirname $0)/netns_datapath data_shutdown $@
}

# $1 -- L2TP version
# $2 -- family
# $3 -- encap
ac_pppoe_data_check()
{
    check $(dirname $0)/netns_datapath ac_pppoe $@
}

#
# Entry point
#

log "Kernel $(current_kernel_version) ($(kernel_version $(current_kernel_version)))"

# Check if IPv6 present
have_ipv6 && HAVE_IPV6=1 || HAVE_IPV6=0
test $HAVE_IPV6 -eq 1 && log "Have IPv6" || log "Have no IPv6"

# Check if L2TP IPv6 is supported
have_l2tpip_ipv6 && HAVE_L2TPIP_IPV6=1 || HAVE_L2TPIP_IPV6=0
test $HAVE_L2TPIP_IPV6 -eq 1 && log "Have L2TP IP encap IPv6" || log "Have no L2TP IP encap IPv6"

# Check if IPv6 peer addresss is supported
have_ipv6_peer && HAVE_IPV6_PEER=1 || HAVE_IPV6_PEER=0
test $HAVE_IPV6_PEER -eq 1 && log "Have IPv6 peer_addr" || log "Have no IPv6 peer_addr"

# Check if network namespace is supported (lo interface in separate namespace)
have_ip_netns && HAVE_IP_NETNS=1 || HAVE_IP_NETNS=0
test $HAVE_IP_NETNS -eq 1 && log "Have net namespaces" || log "Have no net namespaces"

# Check whether kernel supports the UDP socket destructor hook
have_udp_encap_destroy && HAVE_UDP_ENCAP_DESTROY=1 || HAVE_UDP_ENCAP_DESTROY=0
test $HAVE_UDP_ENCAP_DESTROY -eq 1 && log "Have UDP encap_destroy hook" || log "Have no UDP encap_destroy hook"

# Check whether kernel supports the L2TP AC/PPPoE driver
have_l2tp_ac_pppoe && HAVE_L2TP_AC_PPPOE=1 || HAVE_L2TP_AC_PPPOE=0
test $HAVE_L2TP_AC_PPPOE -eq 1 && log "Have L2TP AC/PPPoE driver" || log "Have no L2TP AC/PPPoE driver"

# AC/PPPoE tests require the name of a local Ethernet interface
ETH_IFNAME=$(ip link | \
    awk '/^[0-9]+:/ { gsub(/:/, "", $2); ifname=$2 }
         /link\/ether/ { print ifname; f=1; exit }
         END { exit f?0:1 }') || die "Can't locate Ethernet interface"
log "Have Ethernet interface $ETH_IFNAME"

# L2TPv2, IPv4
tc_api_v2_inet_nopw() { v2_tunl_check inet; }
tc_api_v2_inet_ppp() { v2_tunl_check inet ppp; }
if test $HAVE_L2TP_AC_PPPOE -eq 1
then
    tc_api_v2_inet_pppac() { v2_tunl_check inet "pppac -N $ETH_IFNAME -i 1234 -M 04:7d:7b:da:23:9c"; }
fi

# L2TPv2, IPv6
if test $HAVE_IPV6 -eq 1
then
    tc_api_v2_inet6_nopw() { v2_tunl_check inet6; }
    tc_api_v2_inet6_ppp() { v2_tunl_check inet6 ppp; }
    if test $HAVE_L2TP_AC_PPPOE -eq 1
    then
        tc_api_v2_inet_pppac() { v2_tunl_check inet6 "pppac -N $ETH_IFNAME -i 1234 -M 04:7d:7b:da:23:9c"; }
    fi
fi

# L2TPv3, UDP encap, IPv4
tc_api_v3_udp_inet_nopw() { v3_tunl_check udp inet; }
tc_api_v3_udp_inet_eth() { v3_tunl_check udp inet eth; }
tc_api_v3_udp_inet_ppp() { v3_tunl_check udp inet ppp; }
if test $HAVE_L2TP_AC_PPPOE -eq 1
then
    tc_api_v2_inet_pppac() { v3_tunl_check udp inet "pppac -N $ETH_IFNAME -i 1234 -M 04:7d:7b:da:23:9c"; }
fi

# L2TPv3, IP encap, IPv4
tc_api_v3_ip_inet_nopw() { v3_tunl_check ip inet; }
tc_api_v3_ip_inet_eth() { v3_tunl_check ip inet eth; }
tc_api_v3_ip_inet_ppp() { v3_tunl_check ip inet ppp; }
if test $HAVE_L2TP_AC_PPPOE -eq 1
then
    tc_api_v2_inet_pppac() { v3_tunl_check ip inet "pppac -N $ETH_IFNAME -i 1234 -M 04:7d:7b:da:23:9c"; }
fi

# L2TPv3, UDP encap, IPv6
if test $HAVE_IPV6 -eq 1
then
    tc_api_v3_udp_inet6_nopw() { v3_tunl_check udp inet6; }
    tc_api_v3_udp_inet6_eth() { v3_tunl_check udp inet6 eth; }
    tc_api_v3_udp_inet6_ppp() { v3_tunl_check udp inet6 ppp; }
    if test $HAVE_L2TP_AC_PPPOE -eq 1
    then
        tc_api_v2_inet_pppac() { v3_tunl_check udp inet6 "pppac -N $ETH_IFNAME -i 1234 -M 04:7d:7b:da:23:9c"; }
    fi
fi

# L2TPv3, IP encap, IPv6
if test $HAVE_L2TPIP_IPV6 -eq 1
then
    tc_api_v3_ip_inet6_nopw() { v3_tunl_check ip inet6; }
    tc_api_v3_ip_inet6_eth() { v3_tunl_check ip inet6 eth; }
    tc_api_v3_ip_inet6_ppp() { v3_tunl_check ip inet6 ppp; }
    if test $HAVE_L2TP_AC_PPPOE -eq 1
    then
        tc_api_v2_inet_pppac() { v3_tunl_check ip inet6 "pppac -N $ETH_IFNAME -i 1234 -M 04:7d:7b:da:23:9c"; }
    fi
fi

# $1 -- mode - delete or query
# $2 -- family
# $3 -- encap
do_tunnel_delete_or_query_race()
{
    local mode="$1"
    local family="$2"
    local encap="$3"
    local i=

    check test $(count_tunnels) -eq 0

    for i in 1 2 3 4 5
    do
        delay_no_tunnel
        OPT_SILENT=1 check $(dirname $0)/tunl_${mode}_race -f $family -e $encap -c 150
    done

    delay_no_tunnel
    check test $(count_tunnels) -eq 0
}

# Tunnel delete with userspace thread races
if test $HAVE_UDP_ENCAP_DESTROY -eq 1
then
    tc_race_delete_inet_udp() { do_tunnel_delete_or_query_race delete inet udp; }
    tc_race_delete_inet6_udp() { do_tunnel_delete_or_query_race delete inet6 udp; }
fi
tc_race_delete_inet_ip() { do_tunnel_delete_or_query_race delete inet ip; }
if test $HAVE_L2TPIP_IPV6 -eq 1
then
    tc_race_delete_inet6_ip() { do_tunnel_delete_or_query_race delete inet6 ip; }
fi

# Tunnel query with userspace thread races
if test $HAVE_UDP_ENCAP_DESTROY -eq 1
then
    tc_race_query_inet_udp() { do_tunnel_delete_or_query_race query inet udp; }
    tc_race_query_inet6_udp() { do_tunnel_delete_or_query_race query inet6 udp; }
fi
tc_race_query_inet_ip() { do_tunnel_delete_or_query_race query inet ip; }
if test $HAVE_L2TPIP_IPV6 -eq 1
then
    tc_race_query_inet6_ip() { do_tunnel_delete_or_query_race query inet6 ip; }
fi

# Datapath tests require lo interfaces configurable per namespace
if test $HAVE_IP_NETNS -eq 1
then
    tc_data_v2_inet_udp_ppp() { session_data_check 2 inet udp ppp 0; }

    tc_data_v3_inet_udp_ppp() { session_data_check 3 inet udp ppp 0; }
    tc_data_v3_inet_udp_ppp_cookie4() { session_data_check 3 inet udp ppp 4; }
    tc_data_v3_inet_udp_ppp_cookie8() { session_data_check 3 inet udp ppp 8; }

    tc_data_v3_inet_udp_eth() { session_data_check 3 inet udp eth 0; }
    tc_data_v3_inet_udp_eth_cookie4() { session_data_check 3 inet udp eth 4; }
    tc_data_v3_inet_udp_eth_cookie8() { session_data_check 3 inet udp eth 8; }

    tc_data_v3_inet_ip_ppp() { session_data_check 3 inet ip ppp 0; }
    tc_data_v3_inet_ip_ppp_cookie4() { session_data_check 3 inet ip ppp 4; }
    tc_data_v3_inet_ip_ppp_cookie8() { session_data_check 3 inet ip ppp 8; }

    tc_data_v3_inet_ip_eth() { session_data_check 3 inet ip eth 0; }
    tc_data_v3_inet_ip_eth_cookie4() { session_data_check 3 inet ip eth 4; }
    tc_data_v3_inet_ip_eth_cookie8() { session_data_check 3 inet ip eth 8; }

    tc_cookie_mismatch_v3_inet_udp_cookie4() { cookie_mismatch_check inet udp eth 4 4; }
    tc_cookie_mismatch_v3_inet_udp_cookie8() { cookie_mismatch_check inet udp eth 8 8; }
    tc_cookie_mismatch_v3_inet_udp_no_peer_cookie() { cookie_mismatch_check inet udp eth 0 4; }

    tc_cookie_mismatch_v3_inet_ip_cookie4() { cookie_mismatch_check inet ip eth 4 4; }
    tc_cookie_mismatch_v3_inet_ip_cookie8() { cookie_mismatch_check inet ip eth 8 8; }
    tc_cookie_mismatch_v3_inet_ip_no_peer_cookie() { cookie_mismatch_check inet ip eth 0 4; }

    tc_data_shutdown_v2_inet_udp_ppp() { data_shutdown_check 2 inet udp ppp; }

    tc_data_shutdown_v3_inet_udp_ppp() { data_shutdown_check 3 inet udp ppp; }
    tc_data_shutdown_v3_inet_ip_ppp() { data_shutdown_check 3 inet ip ppp; }
    tc_data_shutdown_v3_inet_udp_eth() { data_shutdown_check 3 inet udp eth; }
    tc_data_shutdown_v3_inet_ip_eth() { data_shutdown_check 3 inet ip eth; }

    if test $HAVE_L2TP_AC_PPPOE -eq 1
    then
        tc_ac_pppoe_v2_inet_udp() { ac_pppoe_data_check 2 inet udp; }
        tc_ac_pppoe_v3_inet_udp() { ac_pppoe_data_check 3 inet udp; }
        tc_ac_pppoe_v3_inet_ip() { ac_pppoe_data_check 3 inet ip; }
    fi

    # Datapath tests require ip addr add <local-addr> peer <peer-addr> support
    if test $HAVE_IPV6_PEER -eq 1
    then
        tc_data_v2_inet6_udp_ppp() { session_data_check 2 inet6 udp ppp 0; }

        tc_data_v3_inet6_udp_ppp() { session_data_check 3 inet6 udp ppp 0; }
        tc_data_v3_inet6_udp_ppp_cookie4() { session_data_check 3 inet6 udp ppp 4; }
        tc_data_v3_inet6_udp_ppp_cookie8() { session_data_check 3 inet6 udp ppp 8; }

        tc_data_v3_inet6_udp_eth() { session_data_check 3 inet6 udp eth 0; }
        tc_data_v3_inet6_udp_eth_cookie4() { session_data_check 3 inet6 udp eth 4; }
        tc_data_v3_inet6_udp_eth_cookie8() { session_data_check 3 inet6 udp eth 8; }

        tc_cookie_mismatch_v3_inet6_udp_cookie4() { cookie_mismatch_check inet6 udp eth 4 4; }
        tc_cookie_mismatch_v3_inet6_udp_cookie8() { cookie_mismatch_check inet6 udp eth 8 8; }
        tc_cookie_mismatch_v3_inet6_udp_no_peer_cookie() { cookie_mismatch_check inet6 udp eth 0 4; }

        tc_data_shutdown_v2_inet6_udp_ppp() { data_shutdown_check 2 inet6 udp ppp; }

        tc_data_shutdown_v3_inet6_udp_ppp() { data_shutdown_check 3 inet6 udp ppp; }
        tc_data_shutdown_v3_inet6_udp_eth() { data_shutdown_check 3 inet6 udp eth; }

        if test $HAVE_L2TP_AC_PPPOE -eq 1
        then
            tc_ac_pppoe_v2_inet6_udp() { ac_pppoe_data_check 2 inet6 udp; }
            tc_ac_pppoe_v3_inet6_udp() { ac_pppoe_data_check 3 inet6 udp; }
        fi

        if test $HAVE_L2TPIP_IPV6 -eq 1
        then
            tc_data_v3_inet6_ip_ppp() { session_data_check 3 inet6 ip ppp 0; }
            tc_data_v3_inet6_ip_ppp_cookie4() { session_data_check 3 inet6 ip ppp 4; }
            tc_data_v3_inet6_ip_ppp_cookie8() { session_data_check 3 inet6 ip ppp 8; }

            tc_data_v3_inet6_ip_eth() { session_data_check 3 inet6 ip eth 0; }
            tc_data_v3_inet6_ip_eth_cookie4() { session_data_check 3 inet6 ip eth 4; }
            tc_data_v3_inet6_ip_eth_cookie8() { session_data_check 3 inet6 ip eth 8; }

            tc_cookie_mismatch_v3_inet6_ip_cookie4() { cookie_mismatch_check inet6 ip eth 4 4; }
            tc_cookie_mismatch_v3_inet6_ip_cookie8() { cookie_mismatch_check inet6 ip eth 8 8; }
            tc_cookie_mismatch_v3_inet6_ip_no_peer_cookie() { cookie_mismatch_check inet6 ip eth 0 4; }
    
            tc_data_shutdown_v3_inet6_ip_ppp() { data_shutdown_check 3 inet6 ip ppp; }
            tc_data_shutdown_v3_inet6_ip_eth() { data_shutdown_check 3 inet6 ip eth; }

            if test $HAVE_L2TP_AC_PPPOE -eq 1
            then
                tc_ac_pppoe_v3_inet6_ip() { ac_pppoe_data_check 3 inet6 ip; }
            fi
        fi
    fi
fi

# Datapath sequence number checks are agnostic to the pseudowire type and socket
# address family, and hence are all handled by a single test application which covers
# L2TPv2 and L2TPv3 sessions
tc_data_seqnum()
{
    check $(dirname $0)/seqnum
}

kmodrefleak_final_check()
{
    local ret=0
    kmodrefleak_check force || ret=1
    return $ret
}

show_usage()
{
    cat << __EOF__
    Name:   $(basename $0)
    Desc:   A unit and test suite for the Linux kernel L2TP code
    Usage:  $(basename $0) [options]
        -h  print this usage information
        -l  list available tests
        -k  enable kmemleak checking
        -m  enable kernel module refcount leak checking
        -e  exit on first test failure
        -t  specify testcases to run (e.g. -t "tc_api_v3_ip_inet_ppp tc_api_v3_ip_inet6_ppp")
        -v  log verbose debug
__EOF__
}

show_tests()
{
    local tc=
    local c=0
    echo "Available testcases:"
    for tc in $TESTCASES
    do
        c=$((c+1))
        echo "   testcase $c : $tc"
    done
}

#
# Entry point
#
TESTCASES=$(compgen -A function | grep ^tc_)

while getopts "hlkmevt:" opt
do
    case $opt in
    h) show_usage; exit 0;;
    l) show_tests; exit 0;;
    k) DO_KMEMLEAK_CHECK=1;;
    m) DO_KMODREFLEAK_CHECK=1;;
    e) EXIT_ON_FIRST_ERROR=1;;
    v) VERBOSE=1;;
    t) TESTCASES=$OPTARG;;
    ?) exit 1;;
    esac
done

if test 1 -eq $DO_KMEMLEAK_CHECK
then
    test -f $KMEMLEAK || log "WARNING: kernel mem leak checks disabled: $KMEMLEAK not present"
fi

if test "root" != $(whoami)
then
    log "Root capabilities are required to run the test suite!"
    exit 1
fi

# Load modules prior to running tests.
# Although the L2TP subsystem supports module autoloading, the module
# reference leak detection expects all modules to be loaded prior to
# startup so it can use a simple diff approach to detect module reference
# count changes.
l2tp_modules="l2tp_core l2tp_ip l2tp_ip6 l2tp_eth l2tp_ppp l2tp_netlink"
test $HAVE_L2TP_AC_PPPOE -eq 1 && l2tp_modules="$l2tp_modules l2tp_ac_pppoe"
for m in $l2tp_modules
do
    modprobe $m
done

# If kmodrefleak isn't enabled, set it up so that
# kmodrefleak_final_check reports any leaks after running all other
# tests.
if test 0 -eq $DO_KMODREFLEAK_CHECK
then
    kmodrefleak_setup force
fi

ntests=0
nfails=0
for tc in $TESTCASES
do
    ntests=$((ntests+1))
    log "testcase $ntests : $tc"
    check_fail=$CHECK_FAIL
    runtest $tc
    if test $? -ne 0 || test $CHECK_FAIL -ne $check_fail
    then
        err "testcase $tc FAILED"
        nfails=$((nfails+1))
    else
        log "testcase $ntests : ok"
    fi
done

if test 0 -eq $DO_KMODREFLEAK_CHECK -a 0 -eq $nfails
then
    kmodrefleak_final_check || cat << EOF

l2tp kernel module refcount leaks detected.
Rerun with -m to enable leak checks per test to help diagnose the problem.

EOF
fi

report_and_exit $ntests $CHECK_COUNT $nfails 0
